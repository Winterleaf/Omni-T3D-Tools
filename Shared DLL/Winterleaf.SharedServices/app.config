<?xml version="1.0"?>
<configuration>
    <configSections>
        <sectionGroup name="userSettings" type="System.Configuration.UserSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
            <section name="Winterleaf.SharedServices.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" allowExeDefinition="MachineToLocalUser" requirePermission="false" />
            <section name="OmniAddin.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" allowExeDefinition="MachineToLocalUser" requirePermission="false"/>
        </sectionGroup>
    </configSections>
    <userSettings>
        <Winterleaf.SharedServices.Properties.Settings>
            <setting name="OmniAddin_WLEAuth_OMNIAuth" serializeAs="String">
                <value>https://www.winterleafentertainment.com/DesktopModules/WLERegistration/OMNIAuth.asmx</value>
            </setting>
            <setting name="WorkingFolder" serializeAs="String">
                <value />
            </setting>
            <setting name="PreGen_CPP_Constants_cfg" serializeAs="String">
                <value>///************************************************************************************
///Any constant that is used in the system as a default variable for a console function
///must be defined in this file.
///It should be defined as C++ constant Name &lt;##&gt; C# Syntax &lt;NL&gt;
///************************************************************************************

MatrixF::Identity	##BEGIN##	new TransformF("0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000")##END##
ColorF::ZERO		##BEGIN##	new ColorF(0.0f, 0.0f, 0.0f,0.0f)##END##
ColorF::ONE		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::WHITE		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::BLACK		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::RED		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::GREEN		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::BLUE		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##


Point2I::Zero		##BEGIN##	new Point2I(0,0)				##END##
Point2I::One		##BEGIN##	new Point2I(1,1)				##END##
Point2I::Min		##BEGIN##	new Point2I(int.MinValue,int.MinValue)				##END##
Point2I::Max		##BEGIN##	new Point2I(int.MaxValue,int.MaxValue)				##END##

///Point2F::One(1.0f, 1.0f);
///Point2F::Zero(0.0f, 0.0f);
///Point2F::Min(F32_MIN, F32_MIN);
///Point2F::Max(F32_MAX, F32_MAX);

///Point2D::One(1.0, 1.0);
///Point2D::Zero(0.0, 0.0);

///Point3I::One(1, 1, 1);
///Point3I::Zero(0, 0, 0);

Point3F::One		##BEGIN##	new Point3F(1.0f, 1.0f, 1.0f)##END##
Point3F::Zero		##BEGIN##	new Point3F(0.0f, 0.0f, 0.0f)##END##
Point3F::Min		##BEGIN##	new Point3F(float.MinValue, float.MinValue, float.MinValue)##END##
Point3F::Max		##BEGIN##	new Point3F(float.MaxValue, float.MaxValue, float.MaxValue)##END##
Point3F::UnitX		##BEGIN##	new Point3F(1.0f, .0f, .0f)##END##
Point3F::UnitY		##BEGIN##	new Point3F(.0f, 1.0f, .0f)##END##
Point3F::UnitZ		##BEGIN##	new Point3F(.0f, .0f, 1.0f)##END##

///Point4I::One(1, 1, 1, 1);
///Point4I::Zero(0, 0, 0, 0);

///Point4F::One(1.0f, 1.0f, 1.0f, 1.0f);
///Point4F::Zero(0.0f, 0.0f, 0.0f, 0.0f);

MBOkCancel		##BEGIN##	1##END##
MIInformation		##BEGIN##	1##END##


TransformF::Identity	##BEGIN##	new TransformF(0,0,0,0,0,1,0)##END##

NULL			##BEGIN##	null##END##

TSPathShape::Forward	##BEGIN##	TypePathShapeState.Forward##END##</value>
            </setting>
            <setting name="PreGen_CPP_IgnoreClassFunction_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PosGen_CPP_FindReplace.cfg
///Description:
///		Comments require 3 slashes and must be first symbols on line
///		This file directs the parser not to parse console functions
///		in the engine.
///
///		This supports wildcards.
///		C++ Class Name:*;	--Any ConsoleFunction/ConsoleMethod/DefineConsoleMethod/
///								DefineConsoleFunction/DefineEngineFunction/DefineEngineMethod 
///								attached to that Class 
///								will not be parsed.
///
///		*:Function Name;	--Any ConsoleMethod/DefineConsoleMethod/
///								DefineConsoleFunction/DefineEngineFunction/DefineEngineMethod
///								regardless of the c++
///								class it belongs to will not be parsed.
///
///		*:_Function Name;	--The underscore is for denoting a ConsoleFunction versus a
///							 DefineConsoleFunction
///************************************************************************************

*:sbmDumpStats;
*:sbmDumpStrings;
*:cls;

*:validateMemory;
*:freeMemoryDump;
*:flagCurrentAllocs;
*:dumpUnflaggedAllocs;
*:dumpAlloc;
*:dumpMemSnapshot;
*:inputLog;


*:_validateMemory;
*:_freeMemoryDump;
*:_flagCurrentAllocs;
*:_dumpUnflaggedAllocs;
*:_dumpAlloc;
*:_dumpMemSnapshot;
NetConnection:setLogging;
*:_inputLog;
Path:getPathId;
*:_sbmDumpStats;
*:_sbmDumpStrings;</value>
            </setting>
            <setting name="PreGen_CPP_ObjParseDef_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PreGen_CPP_ObjParseDef.cfg
///Description:
/// Ok, this file handles generating the C++ to serialize and deserialize 
/// complex objects to strings and vice versa
/// DeserializeString will 
///						--replace {0} with the C++ type
///						--replace {1} with the parameter name, make sure prefix {1} with x__
///
/// Note: this mapping is only used if the object type is not in PreGen_CPP_SimObjectBaseClasses.cfg
///          This is used for return Types.
///************************************************************************************

///For example...
#ObjectType#=VectorF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f\", &amp;{1}.x, &amp;{1}.y, &amp;{1}.z);\r\n

///DeserializeString Generates----&gt;Point3F size = Point3F(); sscanf(x__size,"%f %f %f", &amp;size.x,&amp;size.y,&amp;size.z);

#SerializeString#=dSprintf(retval,1024,\"%f %f %f \",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);\r\nreturn;\r\n

///SerializeString Generates------&gt;dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);

///Whether this object needs to be created as a Pointer in C++
#IsObject#=0

#ObjectType#=TransformF
#DeserializeString#={0} {1} = {0}();\r\nsscanf( x__{1},\"%f %f %f %f %f %f %f\", &amp;{1}.mPosition.x, &amp;{1}.mPosition.y, &amp;{1}.mPosition.z, &amp;{1}.mOrientation.axis.x, &amp;{1}.mOrientation.axis.y, &amp;{1}.mOrientation.axis.z, &amp;{1}.mOrientation.angle);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f %f %f %f \",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=String
#DeserializeString#={0} {1} = {0}( x__{1});
#SerializeString#=dSprintf(retval,16384,\"%s\",wle_returnObject.c_str());\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=SFXStatus
#DeserializeString#={0} {1} = ({0})__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=RectSpacingI
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1}, \"%i %i %i %i\", &amp;{1}.top, &amp;{1}.bottom, &amp;{1}.left, &amp;{1}.right);
#SerializeString#=dSprintf(retval,1024,\"%i %i %i %i \",wle_returnObject.top,wle_returnObject.bottom,wle_returnObject.left,wle_returnObject.right);\r\nreturn;\r\n
#IsObject#=0


#ObjectType#=Point2I
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%i %i\",&amp;{1}.x,&amp;{1}.y);
#SerializeString#=dSprintf(retval,1024,\"%i %i \",wle_returnObject.x,wle_returnObject.y);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=Point3I
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%i %i %i\",&amp;{1}.x,&amp;{1}.y,&amp;{1}.z);
#SerializeString#=dSprintf(retval,1024,\"%i %i %i \",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=Point2F
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f\",&amp;{1}.x,&amp;{1}.y);
#SerializeString#=dSprintf(retval,1024,\"%f %f \",wle_returnObject.x,wle_returnObject.y);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=Point3F
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f\",&amp;{1}.x,&amp;{1}.y,&amp;{1}.z);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f \",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=GuiWindowCtrl
#DeserializeString#={0} {1} = GuiCanvas::findObject(x__{1}); 
#SerializeString#=dSprintf(retval,1024,\"%i\",wle_returnObject-&gt;getId());\r\nreturn;\r\n
///In this case, this object is not derrived from simobject so we need to flag it as a object.  I.E. pointer
#IsObject#=1

#ObjectType#=ColorF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f %f\",&amp;{1}.red,&amp;{1}.green,&amp;{1}.blue,&amp;{1}.alpha);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f \",wle_returnObject.red,wle_returnObject.green,wle_returnObject.blue,wle_returnObject.alpha);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=ColorI
#DeserializeString#={0} {1} = {0}();\r\n{{\r\nint r,g,b,a;\r\nsscanf(x__{1},"%d %d %d %d ",&amp;r,&amp;g,&amp;b,&amp;a);\r\n{1}.red =(unsigned short)r;\r\n{1}.green=(unsigned short)g;\r\n{1}.blue=(unsigned short)b;\r\n{1}.alpha=(unsigned short)a;\r\n}}\r\n
#SerializeString#=dSprintf(retval,1024,\"%d %d %d %d \",(int)wle_returnObject.red,(int)wle_returnObject.green,(int)wle_returnObject.blue,(int)wle_returnObject.alpha);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=WorldEditor::AlignmentType
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=GuiGraphType
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=MBButtons
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=MBIcons
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=GFXFormat
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=SFXDistanceModel
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=const char
#DeserializeString#=const char* {1} = (const char*)x__{1};\r\n
#SerializeString#=dSprintf(retval,16384,\"%s\",wle_returnObject);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=AngAxisF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f %f\",&amp;{1}.axis.x,&amp;{1}.axis.y,&amp;{1}.axis.z,&amp;{1}.angle);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f \",wle_returnObject.axis.x,wle_returnObject.axis.y,wle_returnObject.axis.z,wle_returnObject.angle);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=Box3F
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f %f %f %f\",&amp;{1}.minExtents.x,&amp;{1}.minExtents.y,&amp;{1}.minExtents.z,&amp;{1}.maxExtents.x,&amp;{1}.maxExtents.y,&amp;{1}.maxExtents.z);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f %f %f \",wle_returnObject.minExtents.x,wle_returnObject.minExtents.y,wle_returnObject.minExtents.z,wle_returnObject.maxExtents.x,wle_returnObject.maxExtents.y,wle_returnObject.maxExtents.z);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=SimXMLDocument
#DeserializeString#= AssertFatal( 1, "Not Defined" );
#SerializeString#=dSprintf(retval,1024,\"%i\",wle_returnObject-&gt;getId());\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=MatrixF
#DeserializeString#= AssertFatal( 1, "Not Defined" );\r\n
///#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f %f %f %f %f %f\",TransformF(wle_returnObject).mPosition.x,TransformF(wle_returnObject).mPosition.y,TransformF(wle_returnObject).mPosition.z,TransformF(wle_returnObject).mOrientation.axis.x,TransformF(wle_returnObject).mOrientation.axis.y,TransformF(wle_returnObject).mOrientation.axis.z,TransformF(wle_returnObject).mOrientation.angle);\r\nreturn;\r\n
#SerializeString#=Point3F col0, col1, col2;wle_returnObject.getColumn(0, &amp;col0);wle_returnObject.getColumn(1, &amp;col1);wle_returnObject.getColumn(2, &amp;col2);dSprintf(retval,1024,\"%g %g %g %g %g %g %g %g %g\",col0.x, col0.y, col0.z, col1.x, col1.y, col1.z, col2.x, col2.y, col2.z);\r\nreturn;\r\n

#IsObject#=0

#ObjectType#=Polyhedron
#DeserializeString#= AssertFatal( 1, "Not Defined" );\r\n
#SerializeString#= AssertFatal( 1, "Not Defined" );\r\n
#IsObject#=0



#ObjectType#=EaseF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%d %d %f %f\",&amp;{1}.dir,&amp;{1}.type,&amp;{1}.param[0],&amp;{1}.param[1]);
#SerializeString#=dSprintf(retval,1024,\"%d %d %g %g \",wle_returnObject.dir,wle_returnObject.type,wle_returnObject.param[0],wle_returnObject.param[1]);\r\nreturn;\r\n
#IsObject#=0


#ObjectType#=Point4F
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%g %g %g %g\",&amp;{1}.x,&amp;{1}.y,&amp;{1}.z,&amp;{1}.w);
#SerializeString#=dSprintf(retval,1024,\"%g %g %g %g \",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z,wle_returnObject.w);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=RectF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%g %g %g %g\",&amp;{1}.point.x,&amp;{1}.point.y,&amp;{1}.extent.x,&amp;{1}.extent.y);
#SerializeString#=dSprintf(retval,1024,\"%g %g %g %g \",wle_returnObject.point.x,wle_returnObject.point.y,wle_returnObject.extent.x,wle_returnObject.extent.y);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=RectI
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%d %d %d %d\",&amp;{1}.point.x,&amp;{1}.point.y,&amp;{1}.extent.x,&amp;{1}.extent.y);
#SerializeString#=dSprintf(retval,1024,\"%d %d %d %d \",wle_returnObject.point.x,wle_returnObject.point.y,wle_returnObject.extent.x,wle_returnObject.extent.y);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=PathShapeState
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0</value>
            </setting>
            <setting name="PreGen_CPP_SimObjectBaseClasses_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PreGen_CPP_SimObjectBaseClasses.cfg
///Description:
///		Comments require 3 slashes and must be first symbols on line
///		This file is where you put any object you would use Sim::findObject() to find 
///		Any new simobject based classes which are used as parameters or return types
///		need to be added to this file
///************************************************************************************
 
 SimSet SimObject SimGroup SFXSource SFXParameter
 SceneObject RenderBinManager GuiControl GuiCanvas 
 GameBase ConvexShape ArrayObject GuiControlProfile 
 GuiCursor MessageVector MissionArea Material 
 NetConnection ShapeBase SFXTrack ShapeBaseImageData 
 GameBaseData SFXProfile WheeledVehicleTire 
 WheeledVehicleSpring HTTPObject TCPObject SimXMLDocument 
 FileObject FileStreamObject StreamObject ZipObject 
 DecalRoad MeshRoad River ScatterSky 
 ForestWindEmitter CubemapData DebugDrawer GuiTSCtrl 
 GuiBitmapButtonCtrl GuiButtonBaseCtrl GuiCheckBoxCtrl 
 GuiIconButtonCtrl GuiSwatchButtonCtrl GuiAutoScrollCtrl 
 GuiDragAndDropControl GuiDynamicCtrlArrayControl GuiFormCtrl 
 GuiFrameSetCtrl GuiPaneControl GuiRolloutCtrl GuiScrollCtrl 
 GuiStackControl GuiTabBookCtrl GuiBitmapCtrl 
 GuiDirectoryFileListCtrl GuiGameListMenuCtrl GuiGameListOptionsCtrl 
 GuiListBoxCtrl GuiMLTextCtrl GuiPopUpMenuCtrlEx GuiSliderCtrl 
 GuiTabPageCtrl GuiTextCtrl GuiTextEditCtrl GuiTextListCtrl 
 GuiTreeViewCtrl GuiEditCtrl GuiImageList GuiMenuBar 
 GuiShapeEdPreview GuiMessageVectorCtrl GuiProgressBitmapCtrl 
 GuiTheoraCtrl EditTSCtrl GuiMissionAreaCtrl WorldEditor 
 InteriorInstance ShaderData PostEffect RenderPassManager 
 RenderPassStateToken SFXController SFXSound SFXState 
 SFXFMODEventGroup ActionMap NetObject AIPlayer 
 Camera Debris GroundPlane GuiMaterialPreview 
 GuiObjectView Item LightBase LightDescription 
 LightFlareData PathCamera PhysicalZone Player 
 Projectile ProximityMine RigidShape ShapeBaseData 
 Trigger TSStatic Zone DecalData RenderMeshExample 
 Lightning GuiGraphCtrl FileDialog Portal 
 Precipitation GameConnection 
 PhysicsForce SFXEmitter AITurretShape TurretShape 
 FlyingVehicle WheeledVehicle TerrainBlock PhysicsShape 
 DynamicConsoleMethodComponent SimComponent ConsoleLogger 
 FieldBrushObject PersistenceManager SimPersistSet SkyBox 
 Sun GuiMeshRoadEditorCtrl GuiRiverEditorCtrl GuiRoadEditorCtrl 
 Forest ForestBrush ForestBrushTool ForestEditorCtrl 
 ForestSelectionTool GuiToolboxButtonCtrl GuiColorPickerCtrl 
 GuiFileTreeCtrl GuiGradientCtrl GuiMaterialCtrl GuiPopUpMenuCtrl 
 DbgFileView DbgFileView GuiFilterCtrl GuiInspector 
 GuiInspectorTypeFileName GuiInspectorTypeBitMask32 GuiParticleGraphCtrl 
 GuiInspectorDynamicField GuiInspectorDynamicGroup GuiInspectorField 
 GuiVariableInspector GuiIdleCamFadeBitmapCtrl GuiTickCtrl 
 CreatorTree EditManager GuiConvexEditorCtrl GuiDecalEditorCtrl 
 GuiMissionAreaEditorCtrl GuiTerrPreviewCtrl TerrainSmoothAction 
 TerrainEditor MECreateUndoAction MEDeleteUndoAction 
 WorldEditorSelection LangTable PathedInterior SimResponseCurve 
 MenuBar PopupMenu AIClient AIConnection 
 SpawnSphere StaticShape PhysicsDebrisData PxFluid 
 PxMultiActor PxMultiActorData Settings CompoundUndoAction 
 UndoManager UndoAction UndoManager EventManager 
 Message SimDataBlock Prefab TimeOfDay GuiWindowCtrl CubemapData 
 SFXEmitter DecalData RigidShape ShaderData InteriorInstance 
 GuiDragAndDropControl ScriptTickObject GuiChunkedBitmapCtrl GuiClockHud 
 TheoraTextureObject ForestItemData GuiControl ReadXML AIBot PhysBody
 RagDoll RigidBody LevelInfo NavMesh NavPath
  
 Path SimpleNetObject 
  
/// Legacy ParticleSystem
 ParticleEmitterData ParticleEmitterNode ParticleData

/// IPS Architecture
 BillboardParticleData BillboardRibbonParticleData
 SphereEmitterData SphereEmitterNode
 TimedDebugVector

/// IPS SimObjects -----
 ParticleEffect PixelMask
 
 MeshEmitterData RadiusMeshEmitterData NodeMeshEmitterData
 GroundEmitterData GroundEmitterNode
 GraphEmitterData GraphEmitterNode
 MaskEmitterData MaskEmitterNode
 CompositeEmitterData

 PointLightParticleData TSShapeParticleData
 EffectParticleData EmitterParticleData


/// ----- IPS SimObjects
 
 
LeapMotionFrame RazerHydraFrame GuiAutoCompleteCtrl GuiTableControl
 GuiAnimatedControl CloudLayer fxGuiSnooper GameTSCtrl TerrainSolderEdgesAction 
CoverPoint GuiNavEditorCtrl GuiNavEditorUndoAction NavMesh NavPath GuiFlexibleArrayControl 
TSPathShape WalkableShape TSDynamic TSAttachable TSShapeConstructor VolumetricFog 


</value>
            </setting>
            <setting name="PreGen_CPP_TypeConv_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PreGen_CPP_TypeConv.cfg
///Description:
///		Comments require 3 slashes and must be first symbols on line
///		This is where you add any translations on enumerations.;
///		C++ Type A -&gt; Type B;
///		This tells DNT that when it finds a return type of A Convert it to B;
///		
///     If When you compile the C++ you get the error: "'void' function returning a value"
///     Then most likely you need to add an entry here to tell the application
///     How to convert the type.
///     If you have a ConsoleFunction that returns an enumeration type, make sure
///     you add the conversion here.
///************************************************************************************

SFXStatus S32;
WorldEditor::AlignmentType S32;
GuiGraphType S32;
Camera::CameraMotionMode S32;
TSStatic::MaskBits S32;
GFXFormat S32;
SFXDistanceModel S32;
MBButtons S32;
bool S32;
MBIcons S32;
S32 S32;
F32 F32;
float F32;
U32 U32;
int S32;
F64 F64;
domUpAxisType S32;
LeapMotionFramePointableType S32;
PathShapeState S32;</value>
            </setting>
            <setting name="PreGen_CS__TypeConvCPPtoCS_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PreGen_CS__TypeConvCPPtoCS.cfg
///Description:
///		This file is used to map the T3D structs to there CSharp structs
///		If you add a new struct in both the C++ and C#
///		Make sure you add a mapping to PreGen_CPP_ObjParseDef.cfg

///                           Note:  Class is a simObject Model class type, and enum
///                           can be either a hardcoded or generated enumeration.
///************************************************************************************


///Format is C++ Class/Enum (space) CSharp Class/Enum (Space) (Class/Enum)
RectSpacingI RectSpacingI Class;
ColorF ColorF Class;
Point2I Point2I Class;
Point3I Point3I Class;
Point2F Point2F Class;
Point3F Point3F Class;
Point4F Point4F class;
MatrixF MatrixF Class;
TypeMatrixPosition MatrixPosition class;
TypeMatrixRotation AngAxisF class;
TransformF TransformF Class;
VectorF Point3F Class;
ColorI ColorI Class;
Box3F Box3F Class;
domUpAxisType domUpAxisType Enum;
Polyhedron Polyhedron class;
RectI RectI class;
RectF RectF class;
EaseF EaseF class;
AngAxisF AngAxisF class;
///TSStatic is a coded enum, so it's fine
TSStatic::MaskBits TSStatic__MaskBits Enum;
///the rest are parsed so they need to be prefixed w/ Type
WorldEditor::AlignmentType TypeWorldEditorAlignmentType Enum;
GuiGraphType TypeGuiGraphType Enum;
Camera::CameraMotionMode TypeCameraMotionMode Enum;
CameraMotionMode TypeCameraMotionMode Enum;
SFXDistanceModel TypeSFXDistanceModel Enum;
GFXFormat TypeGFXFormat Enum;
MBButtons TypeMBButtons Enum;
MBIcons TypeMBIcons Enum;
SFXStatus TypeSFXStatus Enum;

TypeSFXParameterName TypeSFXParameterName class;
TypeSFXDescriptionName TypeSFXDescriptionName class;
TypeSFXTrackName TypeSFXTrackName class;
TypeSFXEnvironmentName TypeSFXEnvironmentName class;
TypeSFXStateName TypeSFXStateName class;
TypeSFXAmbienceName TypeSFXAmbienceName class;
TypeImageFilename TypeImageFilename class;
TypeSFXSourceName TypeSFXSourceName class;
TypeCubemapName TypeCubemapName class;
TypeMaterialName TypeMaterialName class;
TypeName TypeName class;
TypePrefabFilename TypePrefabFilename class;
TypeShapeFilename TypeShapeFilename class;
TypeTerrainMaterialName TypeTerrainMaterialName class;
TypeGuiControl TypeGuiControl class;

PathShapeState TypePathShapeState Enum;

SimPath::Path Path class;</value>
            </setting>
            <setting name="PreGen_IgnoreSourceFiles_cfg" serializeAs="String">
                <value>///This files specifies which directories to skip when interrogating the c++.
///Any path that contains any of the words below are skipped.
///To Add a new one, just enter it on a blank row with a semicolon.
platformMac;
platformPOSIX;
platformX86UNIX;
dotnetc.cpp;
dotnetc.h;</value>
            </setting>
            <setting name="PreGen_IgnoreSourceFilesForEnumeration_cfg" serializeAs="String">
                <value>///This files specifies which directories to skip when interrogating the c++ for enumerations.
///These files made this list because they used to many #defines and became to problematic to parse.
///Any path that contains any of the words below are skipped.
///To Add a new one, just enter it on a blank row with a semicolon.
console\ast.h;
console\engineAPI.h;
console\engineFunctions.h;
console\dynamicTypes.h;
console\compiler.h;
console\consoleObject.h;
console\engineObject.h;
console\engineTypeInfo.h;
console\engineTypes.h;
console\CMDscan.h;
core\util\journal\journal.h;
gfx\gfxPrimitiveBuffer.h;</value>
            </setting>
        </Winterleaf.SharedServices.Properties.Settings>
        <OmniAddin.Properties.Settings>
            <setting name="OmniAddin_WLEAuth_OMNIAuth" serializeAs="String">
                <value>https://www.winterleafentertainment.com/DesktopModules/WLERegistration/OMNIAuth.asmx</value>
            </setting>
            <setting name="WorkingFolder" serializeAs="String">
                <value/>
            </setting>
            <setting name="PreGen_CPP_Constants_cfg" serializeAs="String">
                <value>///************************************************************************************
///Any constant that is used in the system as a default variable for a console function
///must be defined in this file.
///It should be defined as C++ constant Name &lt;##&gt; C# Syntax &lt;NL&gt;
///************************************************************************************

MatrixF::Identity	##BEGIN##	new TransformF("0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000")##END##
ColorF::ZERO		##BEGIN##	new ColorF(0.0f, 0.0f, 0.0f,0.0f)##END##
ColorF::ONE			##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::WHITE		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::BLACK		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::RED			##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::GREEN		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##
ColorF::BLUE		##BEGIN##	new ColorF(1.0f, 1.0f, 1.0f,1.0f)##END##


Point2I::Zero		##BEGIN##	new Point2I(0,0)				##END##
Point2I::One		##BEGIN##	new Point2I(1,1)				##END##
Point2I::Min		##BEGIN##	new Point2I(int.MinValue,int.MinValue)				##END##
Point2I::Max		##BEGIN##	new Point2I(int.MaxValue,int.MaxValue)				##END##

///Point2F::One(1.0f, 1.0f);
///Point2F::Zero(0.0f, 0.0f);
///Point2F::Min(F32_MIN, F32_MIN);
///Point2F::Max(F32_MAX, F32_MAX);

///Point2D::One(1.0, 1.0);
///Point2D::Zero(0.0, 0.0);

///Point3I::One(1, 1, 1);
///Point3I::Zero(0, 0, 0);

Point3F::One		##BEGIN##	new Point3F(1.0f, 1.0f, 1.0f)##END##
Point3F::Zero		##BEGIN##	new Point3F(0.0f, 0.0f, 0.0f)##END##
Point3F::Min		##BEGIN##	new Point3F(float.MinValue, float.MinValue, float.MinValue)##END##
Point3F::Max		##BEGIN##	new Point3F(float.MaxValue, float.MaxValue, float.MaxValue)##END##
Point3F::UnitX		##BEGIN##	new Point3F(1.0f, .0f, .0f)##END##
Point3F::UnitY		##BEGIN##	new Point3F(.0f, 1.0f, .0f)##END##
Point3F::UnitZ		##BEGIN##	new Point3F(.0f, .0f, 1.0f)##END##

///Point4I::One(1, 1, 1, 1);
///Point4I::Zero(0, 0, 0, 0);

///Point4F::One(1.0f, 1.0f, 1.0f, 1.0f);
///Point4F::Zero(0.0f, 0.0f, 0.0f, 0.0f);

MBOkCancel			##BEGIN##	1##END##
MIInformation		##BEGIN##	1##END##


NULL				##BEGIN##	null##END##</value>
            </setting>
            <setting name="PreGen_CPP_IgnoreClassFunction_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PosGen_CPP_FindReplace.cfg
///Description:
///		Comments require 3 slashes and must be first symbols on line
///		This file directs the parser not to parse console functions
///		in the engine.
///
///		This supports wildcards.
///		C++ Class Name:*;	--Any ConsoleFunction/ConsoleMethod/DefineConsoleMethod/
///								DefineConsoleFunction/DefineEngineFunction/DefineEngineMethod 
///								attached to that Class 
///								will not be parsed.
///
///		*:Function Name;	--Any ConsoleMethod/DefineConsoleMethod/
///								DefineConsoleFunction/DefineEngineFunction/DefineEngineMethod
///								regardless of the c++
///								class it belongs to will not be parsed.
///
///		*:_Function Name;	--The underscore is for denoting a ConsoleFunction versus a
///							 DefineConsoleFunction
///************************************************************************************

*:sbmDumpStats;
*:sbmDumpStrings;
*:cls;

*:validateMemory;
*:freeMemoryDump;
*:flagCurrentAllocs;
*:dumpUnflaggedAllocs;
*:dumpAlloc;
*:dumpMemSnapshot;
*:inputLog;


*:_validateMemory;
*:_freeMemoryDump;
*:_flagCurrentAllocs;
*:_dumpUnflaggedAllocs;
*:_dumpAlloc;
*:_dumpMemSnapshot;
NetConnection:setLogging;
*:_inputLog;
Path:getPathId;
*:_sbmDumpStats;
*:_sbmDumpStrings;</value>
            </setting>
            <setting name="PreGen_CPP_ObjParseDef_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PreGen_CPP_ObjParseDef.cfg
///Description:
/// Ok, this file handles generating the C++ to serialize and deserialize 
/// complex objects to strings and vice versa
/// DeserializeString will 
///						--replace {0} with the C++ type
///						--replace {1} with the parameter name, make sure prefix {1} with x__
///
/// Note: this mapping is only used if the object type is not in PreGen_CPP_SimObjectBaseClasses.cfg
///************************************************************************************

///For example...
#ObjectType#=VectorF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f\", &amp;{1}.x, &amp;{1}.y, &amp;{1}.z);\r\n

///DeserializeString Generates----&gt;Point3F size = Point3F(); sscanf(x__size,"%f %f %f", &amp;size.x,&amp;size.y,&amp;size.z);

#SerializeString#=dSprintf(retval,1024,\"%f %f %f \",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);\r\nreturn;\r\n

///SerializeString Generates------&gt;dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);

///Whether this object needs to be created as a Pointer in C++
#IsObject#=0

#ObjectType#=TransformF
#DeserializeString#={0} {1} = {0}();\r\nsscanf( x__{1},\"%f %f %f %f %f %f %f\", &amp;{1}.mPosition.x, &amp;{1}.mPosition.y, &amp;{1}.mPosition.z, &amp;{1}.mOrientation.axis.x, &amp;{1}.mOrientation.axis.y, &amp;{1}.mOrientation.axis.z, &amp;{1}.mOrientation.angle);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f %f %f %f \",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=String
#DeserializeString#={0} {1} = {0}( x__{1});
#SerializeString#=dSprintf(retval,16384,\"%s\",wle_returnObject.c_str());\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=SFXStatus
#DeserializeString#={0} {1} = ({0})__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=RectSpacingI
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1}, \"%i %i %i %i\", &amp;{1}.top, &amp;{1}.bottom, &amp;{1}.left, &amp;{1}.right);
#SerializeString#=dSprintf(retval,1024,\"%i %i %i %i \",wle_returnObject.top,wle_returnObject.bottom,wle_returnObject.left,wle_returnObject.right);\r\nreturn;\r\n
#IsObject#=0


#ObjectType#=Point2I
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%i %i\",&amp;{1}.x,&amp;{1}.y);
#SerializeString#=dSprintf(retval,1024,\"%i %i \",wle_returnObject.x,wle_returnObject.y);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=Point3I
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%i %i %i\",&amp;{1}.x,&amp;{1}.y,&amp;{1}.z);
#SerializeString#=dSprintf(retval,1024,\"%i %i %i \",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=Point2F
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f\",&amp;{1}.x,&amp;{1}.y);
#SerializeString#=dSprintf(retval,1024,\"%f %f \",wle_returnObject.x,wle_returnObject.y);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=Point3F
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f\",&amp;{1}.x,&amp;{1}.y,&amp;{1}.z);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f \",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=GuiWindowCtrl
#DeserializeString#={0} {1} = GuiCanvas::findObject(x__{1}); 
#SerializeString#=dSprintf(retval,1024,\"%i\",wle_returnObject-&gt;getId());\r\nreturn;\r\n
///In this case, this object is not derrived from simobject so we need to flag it as a object.  I.E. pointer
#IsObject#=1

#ObjectType#=ColorF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f %f\",&amp;{1}.red,&amp;{1}.green,&amp;{1}.blue,&amp;{1}.alpha);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f \",wle_returnObject.red,wle_returnObject.green,wle_returnObject.blue,wle_returnObject.alpha);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=ColorI
#DeserializeString#={0} {1} = {0}();\r\n{{\r\nint r,g,b,a;\r\nsscanf(x__{1},"%d %d %d %d ",&amp;r,&amp;g,&amp;b,&amp;a);\r\n{1}.red =(unsigned short)r;\r\n{1}.green=(unsigned short)g;\r\n{1}.blue=(unsigned short)b;\r\n{1}.alpha=(unsigned short)a;\r\n}}\r\n
#SerializeString#=dSprintf(retval,1024,\"%d %d %d %d \",(int)wle_returnObject.red,(int)wle_returnObject.green,(int)wle_returnObject.blue,(int)wle_returnObject.alpha);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=WorldEditor::AlignmentType
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=GuiGraphType
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=MBButtons
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=MBIcons
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=GFXFormat
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=SFXDistanceModel
#DeserializeString#={0} {1} = ({0})x__{1};
#SerializeString#=return (S32)(wle_returnObject);
#IsObject#=0

#ObjectType#=const char
#DeserializeString#=const char* {1} = (const char*)x__{1};\r\n
#SerializeString#=dSprintf(retval,16384,\"%s\",wle_returnObject);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=AngAxisF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f %f\",&amp;{1}.axis.x,&amp;{1}.axis.y,&amp;{1}.axis.z,&amp;{1}.angle);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f \",wle_returnObject.axis.x,wle_returnObject.axis.y,wle_returnObject.axis.z,wle_returnObject.angle);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=Box3F
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%f %f %f %f %f %f\",&amp;{1}.minExtents.x,&amp;{1}.minExtents.y,&amp;{1}.minExtents.z,&amp;{1}.maxExtents.x,&amp;{1}.maxExtents.y,&amp;{1}.maxExtents.z);
#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f %f %f \",wle_returnObject.minExtents.x,wle_returnObject.minExtents.y,wle_returnObject.minExtents.z,wle_returnObject.maxExtents.x,wle_returnObject.maxExtents.y,wle_returnObject.maxExtents.z);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=SimXMLDocument
#DeserializeString#= AssertFatal( 1, "Not Defined" );
#SerializeString#=dSprintf(retval,1024,\"%i\",wle_returnObject-&gt;getId());\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=MatrixF
#DeserializeString#= AssertFatal( 1, "Not Defined" );\r\n
///#SerializeString#=dSprintf(retval,1024,\"%f %f %f %f %f %f %f %f %f\",TransformF(wle_returnObject).mPosition.x,TransformF(wle_returnObject).mPosition.y,TransformF(wle_returnObject).mPosition.z,TransformF(wle_returnObject).mOrientation.axis.x,TransformF(wle_returnObject).mOrientation.axis.y,TransformF(wle_returnObject).mOrientation.axis.z,TransformF(wle_returnObject).mOrientation.angle);\r\nreturn;\r\n
#SerializeString#=Point3F col0, col1, col2;wle_returnObject.getColumn(0, &amp;col0);wle_returnObject.getColumn(1, &amp;col1);wle_returnObject.getColumn(2, &amp;col2);dSprintf(retval,1024,\"%g %g %g %g %g %g %g %g %g\",col0.x, col0.y, col0.z, col1.x, col1.y, col1.z, col2.x, col2.y, col2.z);\r\nreturn;\r\n

#IsObject#=0

#ObjectType#=Polyhedron
#DeserializeString#= AssertFatal( 1, "Not Defined" );\r\n
#SerializeString#= AssertFatal( 1, "Not Defined" );\r\n
#IsObject#=0



#ObjectType#=EaseF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%d %d %f %f\",&amp;{1}.dir,&amp;{1}.type,&amp;{1}.param[0],&amp;{1}.param[1]);
#SerializeString#=dSprintf(retval,1024,\"%d %d %g %g \",wle_returnObject.dir,wle_returnObject.type,wle_returnObject.param[0],wle_returnObject.param[1]);\r\nreturn;\r\n
#IsObject#=0


#ObjectType#=Point4F
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%g %g %g %g\",&amp;{1}.x,&amp;{1}.y,&amp;{1}.z,&amp;{1}.w);
#SerializeString#=dSprintf(retval,1024,\"%g %g %g %g \",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z,wle_returnObject.w);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=RectF
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%g %g %g %g\",&amp;{1}.point.x,&amp;{1}.point.y,&amp;{1}.extent.x,&amp;{1}.extent.y);
#SerializeString#=dSprintf(retval,1024,\"%g %g %g %g \",wle_returnObject.point.x,wle_returnObject.point.y,wle_returnObject.extent.x,wle_returnObject.extent.y);\r\nreturn;\r\n
#IsObject#=0

#ObjectType#=RectI
#DeserializeString#={0} {1} = {0}();\r\nsscanf(x__{1},\"%d %d %d %d\",&amp;{1}.point.x,&amp;{1}.point.y,&amp;{1}.extent.x,&amp;{1}.extent.y);
#SerializeString#=dSprintf(retval,1024,\"%d %d %d %d \",wle_returnObject.point.x,wle_returnObject.point.y,wle_returnObject.extent.x,wle_returnObject.extent.y);\r\nreturn;\r\n
#IsObject#=0</value>
            </setting>
            <setting name="PreGen_CPP_SimObjectBaseClasses_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PreGen_CPP_SimObjectBaseClasses.cfg
///Description:
///		Comments require 3 slashes and must be first symbols on line
///		This file is where you put any object you would use Sim::findObject() to find 
///		Any new simobject based classes which are used as parameters or return types
///		need to be added to this file
///************************************************************************************
 
 SimSet SimObject SimGroup SFXSource SFXParameter
 SceneObject RenderBinManager GuiControl GuiCanvas 
 GameBase ConvexShape ArrayObject GuiControlProfile 
 GuiCursor MessageVector MissionArea Material 
 NetConnection ShapeBase SFXTrack ShapeBaseImageData 
 GameBaseData SFXProfile WheeledVehicleTire 
 WheeledVehicleSpring HTTPObject TCPObject SimXMLDocument 
 FileObject FileStreamObject StreamObject ZipObject 
 DecalRoad MeshRoad River ScatterSky 
 ForestWindEmitter CubemapData DebugDrawer GuiTSCtrl 
 GuiBitmapButtonCtrl GuiButtonBaseCtrl GuiCheckBoxCtrl 
 GuiIconButtonCtrl GuiSwatchButtonCtrl GuiAutoScrollCtrl 
 GuiDragAndDropControl GuiDynamicCtrlArrayControl GuiFormCtrl 
 GuiFrameSetCtrl GuiPaneControl GuiRolloutCtrl GuiScrollCtrl 
 GuiStackControl GuiTabBookCtrl GuiBitmapCtrl 
 GuiDirectoryFileListCtrl GuiGameListMenuCtrl GuiGameListOptionsCtrl 
 GuiListBoxCtrl GuiMLTextCtrl GuiPopUpMenuCtrlEx GuiSliderCtrl 
 GuiTabPageCtrl GuiTextCtrl GuiTextEditCtrl GuiTextListCtrl 
 GuiTreeViewCtrl GuiEditCtrl GuiImageList GuiMenuBar 
 GuiShapeEdPreview GuiMessageVectorCtrl GuiProgressBitmapCtrl 
 GuiTheoraCtrl EditTSCtrl GuiMissionAreaCtrl WorldEditor 
 InteriorInstance ShaderData PostEffect RenderPassManager 
 RenderPassStateToken SFXController SFXSound SFXState 
 SFXFMODEventGroup ActionMap NetObject AIPlayer 
 Camera Debris GroundPlane GuiMaterialPreview 
 GuiObjectView Item LightBase LightDescription 
 LightFlareData PathCamera PhysicalZone Player 
 Projectile ProximityMine RigidShape ShapeBaseData 
 Trigger TSStatic Zone DecalData RenderMeshExample 
 Lightning GuiGraphCtrl FileDialog Portal 
 Precipitation GameConnection 
 PhysicsForce SFXEmitter AITurretShape TurretShape 
 FlyingVehicle WheeledVehicle TerrainBlock PhysicsShape 
 DynamicConsoleMethodComponent SimComponent ConsoleLogger 
 FieldBrushObject PersistenceManager SimPersistSet SkyBox 
 Sun GuiMeshRoadEditorCtrl GuiRiverEditorCtrl GuiRoadEditorCtrl 
 Forest ForestBrush ForestBrushTool ForestEditorCtrl 
 ForestSelectionTool GuiToolboxButtonCtrl GuiColorPickerCtrl 
 GuiFileTreeCtrl GuiGradientCtrl GuiMaterialCtrl GuiPopUpMenuCtrl 
 DbgFileView DbgFileView GuiFilterCtrl GuiInspector 
 GuiInspectorTypeFileName GuiInspectorTypeBitMask32 GuiParticleGraphCtrl 
 GuiInspectorDynamicField GuiInspectorDynamicGroup GuiInspectorField 
 GuiVariableInspector GuiIdleCamFadeBitmapCtrl GuiTickCtrl 
 CreatorTree EditManager GuiConvexEditorCtrl GuiDecalEditorCtrl 
 GuiMissionAreaEditorCtrl GuiTerrPreviewCtrl TerrainSmoothAction 
 TerrainEditor MECreateUndoAction MEDeleteUndoAction 
 WorldEditorSelection LangTable PathedInterior SimResponseCurve 
 MenuBar PopupMenu AIClient AIConnection 
 SpawnSphere StaticShape PhysicsDebrisData PxFluid 
 PxMultiActor PxMultiActorData Settings CompoundUndoAction 
 UndoManager UndoAction UndoManager EventManager 
 Message SimDataBlock Prefab TimeOfDay GuiWindowCtrl CubemapData 
 SFXEmitter DecalData RigidShape ShaderData InteriorInstance 
 GuiDragAndDropControl ScriptTickObject GuiChunkedBitmapCtrl GuiClockHud 
 TheoraTextureObject ForestItemData GuiControl ReadXML AIBot PhysBody
 RagDoll RigidBody LevelInfo NavMesh NavPath
  
 Path SimpleNetObject 
  
/// Legacy ParticleSystem
 ParticleEmitterData ParticleEmitterNode ParticleData

/// IPS Architecture
 BillboardParticleData BillboardRibbonParticleData
 SphereEmitterData SphereEmitterNode
 TimedDebugVector

/// IPS SimObjects -----
 ParticleEffect PixelMask
 
 MeshEmitterData RadiusMeshEmitterData NodeMeshEmitterData
 GroundEmitterData GroundEmitterNode
 GraphEmitterData GraphEmitterNode
 MaskEmitterData MaskEmitterNode
 CompositeEmitterData

 PointLightParticleData TSShapeParticleData
 EffectParticleData EmitterParticleData


/// ----- IPS SimObjects
 
 
LeapMotionFrame RazerHydraFrame GuiAutoCompleteCtrl GuiTableControl</value>
            </setting>
            <setting name="PreGen_CPP_TypeConv_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PreGen_CPP_TypeConv.cfg
///Description:
///		Comments require 3 slashes and must be first symbols on line
///		This is where you add any translations on enumerations.;
///		C++ Type A -&gt; Type B;
///		This tells DNT that when it finds a return type of A Convert it to B;
///		
///     If When you compile the C++ you get the error: "'void' function returning a value"
///     Then most likely you need to add an entry here to tell the application
///     How to convert the type.
///************************************************************************************

SFXStatus S32;
WorldEditor::AlignmentType S32;
GuiGraphType S32;
Camera::CameraMotionMode S32;
TSStatic::MaskBits S32;
GFXFormat S32;
SFXDistanceModel S32;
MBButtons S32;
bool S32;
MBIcons S32;
S32 S32;
F32 F32;
float F32;
U32 U32;
int S32;
F64 F64;
domUpAxisType S32;
LeapMotionFramePointableType S32;</value>
            </setting>
            <setting name="PreGen_CS__TypeConvCPPtoCS_cfg" serializeAs="String">
                <value>///************************************************************************************
///File Name: PreGen_CS__TypeConvCPPtoCS.cfg
///Description:
///		This file is used to map the T3D structs to there CSharp structs
///		If you add a new struct in both the C++ and C#
///		Make sure you add a mapping to PreGen_CPP_ObjParseDef.cfg
///************************************************************************************


///Format is C++ Class/Enum (space) CSharp Class/Enum (Space) (Class/Enum)
RectSpacingI RectSpacingI Class;
ColorF ColorF Class;
Point2I Point2I Class;
Point3I Point3I Class;
Point2F Point2F Class;
Point3F Point3F Class;
Point4F Point4F class;
MatrixF MatrixF Class;
TypeMatrixPosition MatrixPosition class;
TypeMatrixRotation AngAxisF class;
TransformF TransformF Class;
VectorF Point3F Class;
ColorI ColorI Class;
Box3F Box3F Class;
domUpAxisType domUpAxisType Enum;
Polyhedron Polyhedron class;
RectI RectI class;
RectF RectF class;
EaseF EaseF class;
AngAxisF AngAxisF class;
///TSStatic is a coded enum, so it's fine
TSStatic::MaskBits TSStatic__MaskBits Enum;
///the rest are parsed so they need to be prefixed w/ Type
WorldEditor::AlignmentType TypeWorldEditorAlignmentType Enum;
GuiGraphType TypeGuiGraphType Enum;
Camera::CameraMotionMode TypeCameraMotionMode Enum;
CameraMotionMode TypeCameraMotionMode Enum;
SFXDistanceModel TypeSFXDistanceModel Enum;
GFXFormat TypeGFXFormat Enum;
MBButtons TypeMBButtons Enum;
MBIcons TypeMBIcons Enum;
SFXStatus TypeSFXStatus Enum;

TypeSFXParameterName TypeSFXParameterName class;
TypeSFXDescriptionName TypeSFXDescriptionName class;
TypeSFXTrackName TypeSFXTrackName class;
TypeSFXEnvironmentName TypeSFXEnvironmentName class;
TypeSFXStateName TypeSFXStateName class;
TypeSFXAmbienceName TypeSFXAmbienceName class;
TypeImageFilename TypeImageFilename class;
TypeSFXSourceName TypeSFXSourceName class;
TypeCubemapName TypeCubemapName class;
TypeMaterialName TypeMaterialName class;
TypeName TypeName class;
TypePrefabFilename TypePrefabFilename class;
TypeShapeFilename TypeShapeFilename class;
TypeTerrainMaterialName TypeTerrainMaterialName class;


</value>
            </setting>
            <setting name="PreGen_IgnoreSourceFiles_cfg" serializeAs="String">
                <value>///This files specifies which directories to skip when interrogating the c++.
///Any path that contains any of the words below are skipped.
///To Add a new one, just enter it on a blank row with a semicolon.
platformMac;
platformPOSIX;
platformX86UNIX;
dotnetc.cpp;
dotnetc.h;</value>
            </setting>
            <setting name="PreGen_IgnoreSourceFilesForEnumeration_cfg" serializeAs="String">
                <value>///This files specifies which directories to skip when interrogating the c++ for enumerations.
///These files made this list because they used to many #defines and became to problematic to parse.
///Any path that contains any of the words below are skipped.
///To Add a new one, just enter it on a blank row with a semicolon.
console\ast.h;
console\engineAPI.h;
console\engineFunctions.h;
console\dynamicTypes.h;
console\compiler.h;
console\consoleObject.h;
console\engineObject.h;
console\engineTypeInfo.h;
console\engineTypes.h;
console\CMDscan.h;
core\util\journal\journal.h;
gfx\gfxPrimitiveBuffer.h;</value>
            </setting>
        </OmniAddin.Properties.Settings>
    </userSettings>
<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0"/></startup></configuration>
